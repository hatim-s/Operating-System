alias userSP R0;
alias fileName R1;
alias inodeIndex R2;
alias userAreaPage R3;
alias diskMapEntry R4;
alias counter R5;
alias inodeEntry R6;
alias returnAddress R11;

// //breakpoint;
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE+5*CORE+1]*16 + 13]=SP;	//storing the user stack
userSP = SP;

SP = [PROCESS_TABLE + [SYSTEM_STATUS_TABLE+5*CORE+1]*16 + 11]*512-1;	//SP=kernel stack;
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE+5*CORE+1]*16 + 9]=9; 	//Setting up the mode bit

fileName = [[PTBR + 2*((userSP-4)/512)]*512 + (userSP-4)%512];
returnAddress = [PTBR+2*((userSP-1)/512)]*512 + (userSP-1)%512;

counter = 0;
while (counter < MAX_FILE_NUM) do
	if([INODE_TABLE + counter*16 + 0] == EXEC && [INODE_TABLE + counter*16 + 1] == fileName) then
		break;
	endif;
	counter = counter + 1;
endwhile;

if(counter == MAX_FILE_NUM) then	
	[returnAddress] = -1;								//Storing the return value as -1;
	SP = [PROCESS_TABLE + [SYSTEM_STATUS_TABLE+5*CORE+1]*16+13];				//SP=userstack of earlier process
	[PROCESS_TABLE + [SYSTEM_STATUS_TABLE+5*CORE+1]*16 + 9]=0;
    ireturn;
endif;

multipush(R0, R1, R5, R11);
R1 = ACQUIRE_KERN_LOCK;
call ACCESS_CONTROL;
multipop(R0, R1, R5, R11);

inodeIndex = counter;

multipush(R0, R1, R2, R11);
R1 = EXIT_PROCESS;
R2 = [SYSTEM_STATUS_TABLE+5*CORE+1];
call PROCESS_MANAGER;
multipop(R0, R1, R2, R11);

userAreaPage = [PROCESS_TABLE + [SYSTEM_STATUS_TABLE+5*CORE+1]*16 + 11];
[MEMORY_FREE_LIST + userAreaPage] = 1;
[SYSTEM_STATUS_TABLE+2] = [SYSTEM_STATUS_TABLE+2] - 1;			//Decrementing the MEM_FREE_COUNT

// //breakpoint;	
SP = userAreaPage*512 - 1;
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE+5*CORE+1]*16 + 4] = RUNNING;
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE+5*CORE+1]*16 + 7] = inodeIndex;


// //breakpoint;

//Allocating library pages
[PTBR+0] = 63;
[PTBR+1] = "0100";

[PTBR+2] = 64;
[PTBR+3] = "0100";

//Heap
[PTBR+4] = -1;
[PTBR+5] = "0000";

[PTBR+6] = -1;
[PTBR+7] = "0000";

// //breakpoint;
//Reallocation of pages

//Allocating 2 stack pages
multipush(R0, R1, R2, R3, R11);

R1 = GET_FREE_PAGE;
call MEMORY_MANAGER;
[PTBR + 16] = R0;
[PTBR + 17] = "0110";

R1 = GET_FREE_PAGE;
call MEMORY_MANAGER;
[PTBR + 16] = R0;
[PTBR + 17] = "0110";

multipop (R0, R1, R2, R3, R11);

multipush (R0, R1, R2, R3, R11);
R1 = GET_CODE_PAGE;
R2 = [INODE_TABLE + 16*inodeIndex + 8];
call MEMORY_MANAGER;
[PTBR + 8] = R0;
[PTBR + 9] = "0100";
multipop  (R0, R1, R2, R3, R11);

[PTBR + 10] = -1;
[PTBR + 11] = "0000";
[PTBR + 12] = -1;
[PTBR + 13] = "0000";
[PTBR + 14] = -1;
[PTBR + 15] = "0000";

// //breakpoint;

//Initializing the disk map table for the new process
counter = 0;
while (counter < 10) do
    [DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE+5*CORE+1]*10 + counter]=-1;
    counter = counter+1;
endwhile;


diskMapEntry = DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE+1]*10;
inodeEntry = INODE_TABLE + 16*inodeIndex;
counter = 4;
while (counter < 8) do
    [diskMapEntry + counter] = [inodeEntry + counter];
    counter = counter + 1;
endwhile;

[[PTBR + 16]*512] = [[PTBR + 8]*512 + 1];

R1 = RELEASE_LOCK;
R2 = KERN_LOCK;
call ACCESS_CONTROL;

[PROCESS_TABLE + [SYSTEM_STATUS_TABLE+5*CORE+1]*16 + 9]=0; 						//Clearing the mode bit
SP = 8*512;											//Switching back to user mode;	
// //breakpoint;
ireturn;




