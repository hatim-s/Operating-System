// alias functionNum R1;

// if (functionNum == ACQUIRE_KERN_LOCK) then
//     if (CORE == SECONDARY_CORE) then
//         if ([SYSTEM_STATUS_TABLE+5] != 0 || [SYSTEM_STATUS_TABLE+7] != 0) then
//             [PROCESS_TABLE + [SYSTEM_STATUS_TABLE+6]*16 + 4] = READY;
//             multipush (R1, R2);
//             call SCHEDULER;
//             multipop (R1, R2);
//         endif;
//     endif;

//     while (tsl(KERN_LOCK) == 1) do
//         continue;
//     endwhile;

//     // print "kernel locked";
//     // print CORE;
//     // print [SYSTEM_STATUS_TABLE+(5*CORE)+1];
//     // print [PROCESS_TABLE + [SYSTEM_STATUS_TABLE+(5*CORE)+1]*16 + 9];

//     // // breakpoint;
//     return;
// endif;

// if (functionNum == ACQUIRE_SCHED_LOCK) then
//     // // breakpoint; // 67664

//     while (tsl(SCHED_LOCK) == 1) do
//         continue;
//     endwhile;
    
//     // print "sched locked";
//     // print CORE;
//     // print [SYSTEM_STATUS_TABLE+(5*CORE)+1];

//     // // breakpoint; // 67706
//     return;
// endif;

// if (functionNum == ACQUIRE_GLOCK) then
//     while (tsl(GLOCK) == 1) do
//         continue;
//     endwhile;

//     return;
// endif;

// if (functionNum == RELEASE_LOCK) then
//     // if (R2 == KERN_LOCK) then
//         //     print "kern unlocked";
//     // endif;
//     // if (R2 == SCHED_LOCK) then
//     //     // breakpoint; // 67746
//     //     // print "schd unlocked";
//     // endif;

//     alias lockValueAddress R2;
//     [lockValueAddress] = 0;

//     // // breakpoint; // 67758
//     return;
// endif;



//module 8

//unused bits from access lock table
define TURN_KERN_LOCK 29576;
define FLAGS_KERN_LOCK 29579;

define TURN_SCHED_LOCK 29577;
define FLAGS_SCHED_LOCK 29581;

alias functionNum R1;

if(functionNum == ACQUIRE_KERN_LOCK) then
	if(CORE == SECONDARY_CORE) then
		//if paging status or logout status is on
		if([SYSTEM_STATUS_TABLE + 5] == 1 || [SYSTEM_STATUS_TABLE + 7] == 1) then

			//set secondary core process to ready
			[PROCESS_TABLE + 16*[SYSTEM_STATUS_TABLE+6] + 4] = READY;
			multipush (R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15);
			call CONTEXT_SWITCH;
			multipop  (R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15);
		endif;
	endif;

	multipush(R0);
	alias otherCore R0;
	if(CORE == PRIMARY_CORE) then
		otherCore = SECONDARY_CORE;
	else
		otherCore = PRIMARY_CORE;
	endif;

	[FLAGS_KERN_LOCK + CORE] = 1;
	[TURN_KERN_LOCK] = otherCore;

	while([FLAGS_KERN_LOCK + otherCore] == 1 && [TURN_KERN_LOCK] == otherCore) do
		continue;
	endwhile;

	multipop(R0);
	return;
endif;


if(functionNum == ACQUIRE_SCHED_LOCK) then

	multipush(R0);
	alias otherCore R0;
	if(CORE == PRIMARY_CORE) then
		otherCore = SECONDARY_CORE;
	else
		otherCore = PRIMARY_CORE;
	endif;

	[FLAGS_SCHED_LOCK + CORE] = 1;
	[TURN_SCHED_LOCK] = otherCore;

	while([FLAGS_SCHED_LOCK + otherCore] == 1 && [TURN_SCHED_LOCK] == otherCore) do
		continue;
	endwhile;

	multipop(R0);
	return;
endif;


if(functionNum == RELEASE_LOCK) then
	alias lockVarAddress R2;

	if(lockVarAddress == KERN_LOCK) then
		[FLAGS_KERN_LOCK + CORE] = 0;
	endif;
	if(lockVarAddress == SCHED_LOCK) then
		[FLAGS_SCHED_LOCK + CORE] = 0;
	endif;	
	return;
endif;


















// // MOD 8 Access Control
// alias functionNumber R1; // Function number



// // Acquires KERN_LOCK which is a common access variable to be set before running any critical kernel code (except the scheduler)
// // Before executing any kernel module/interrupt handler, KERN_LOCK is set (by invoking this function) so that the other core waits till the critical action is completed. After completing the critical kernel code, the ReleaseLock function is used to release KERN_LOCK.
// // Called by all system calls, exception handler and timer interrupt handler.
// if(functionNumber == ACQUIRE_KERN_LOCK) then
//     // Arguements are NIL
//     // Returns NIL


//     // if (core is SECONDARY_CORE)
//     if(CORE == SECONDARY_CORE) then
//         // if (PAGING_STATUS or LOGOUT_STATUS is on)
//         if([SYSTEM_STATUS_TABLE+5] == 1 || [SYSTEM_STATUS_TABLE+7] ==1) then
//             // eXpOS design  does not permit a process to execute critical code on the secondary core when paging or logout is ongoing.

//             // Set the state of current process to READY
//             alias processTableEntryAddress R2;
//             processTableEntryAddress = PROCESS_TABLE + ([SYSTEM_STATUS_TABLE+6] * PT_ENTRY_SIZE);
//             [processTableEntryAddress+4] = READY;

//             //  Call the switch_context() function of the Scheduler Module.
//             multipush(R1,R2);
//             call SCHEDULER;
//             multipop(R1,R2);


//             // Note that cheduler Module requires appropriate modifications before running on the NEXSM machine 


//         endif;

//     endif;

//     // Spinlock 
//     while( tsl (KERN_LOCK) == 1) do
//         // Wait till KERN_LOCK is released by the other core
//         continue;
//     endwhile;


// endif;


// // Acquires SCHED_LOCK which is an access variable to be set before running the scheduler. This ensures that if one core has set SCHED_LOCK, the other core will not enter the Scheduler module until the first core completes the scheduling action. 
// // After completing the scheduling action, the ReleaseLock function is used to release SCHED_LOCK.
// if(functionNumber == ACQUIRE_SCHED_LOCK) then
//     // Arguements are NIL
//     // Returns NIL


//     while( tsl (SCHED_LOCK) == 1) do
//         // Wait till SCHED_LOCK is released by the other core
//         continue;
//     endwhile;


// endif;

// if(functionNumber  == ACQUIRE_GLOCK) then
//     // Arguements are NIL
//     // Returns NIL
    
//     // Acquires GLOCK which is a general purpose lock variable that is currently left unused.
   
//     while(tsl(GLOCK) == 1) do
//         continue;
//     endwhile;

// endif;

// if(functionNumber == RELEASE_LOCK) then
//     // Arguements are LockVarAddress
//     // Returns NIL
//     // Store 0 to the address LockVarAddress.
//     alias lockVarAddress R2;
//     [lockVarAddress] = 0;

// endif;



// return;


