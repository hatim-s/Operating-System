// breakpoint;
R1 = ACQUIRE_SCHED_LOCK;
call ACCESS_CONTROL;

alias currentPID R0;
currentPID = [SYSTEM_STATUS_TABLE + 5*CORE + 1];

multipush(BP);

[PROCESS_TABLE + (currentPID * 16) + 12] = SP % 512;
[PROCESS_TABLE + (currentPID * 16) + 14] = PTBR;
[PROCESS_TABLE + (currentPID * 16) + 15] = PTLR;

alias newPID R3;

if (CORE == PRIMARY_CORE) then
	newPID = IDLE_PROCESS;
	if ([SYSTEM_STATUS_TABLE+5] != 0) then
		if ([PROCESS_TABLE + SWAPPER_DAEMON*16 + 4] != WAIT_DISK) then
			newPID = SWAPPER_DAEMON;
		endif;
	else
		alias counter R5;
		counter = currentPID + 1;

		if ([SYSTEM_STATUS_TABLE+7] == 0 || [SYSTEM_STATUS_TABLE+6] == 14) then
			while((counter % MAX_PROC_NUM) != currentPID) do
				if (counter % MAX_PROC_NUM == 0 || counter % MAX_PROC_NUM >= 14 || counter % MAX_PROC_NUM == [SYSTEM_STATUS_TABLE+6]) then
					counter = counter + 1;
					continue;
				endif;

				if([PROCESS_TABLE + 16*(counter%16) + 6]==0 && ([PROCESS_TABLE + (counter%16)*16 + 4]==CREATED || [PROCESS_TABLE + (counter%16)*16 + 4]==READY)) then
					newPID = counter % 16;
					break;
				endif;
				
				counter = counter + 1;	
			endwhile;
		endif;
	endif;
else
	newPID = IDLE2_PROCESS;
	if ([SYSTEM_STATUS_TABLE+5] == 0 && [SYSTEM_STATUS_TABLE+7] == 0) then
		alias counter R5;
		counter = currentPID + 1;

		while((counter % MAX_PROC_NUM) != currentPID) do
			if (counter % MAX_PROC_NUM <= 2 || counter % MAX_PROC_NUM == 15 || counter % MAX_PROC_NUM == [SYSTEM_STATUS_TABLE+1]) then
				counter = counter + 1;
				continue;
			endif;

			if([PROCESS_TABLE + 16*(counter%16) + 6]==0 && ([PROCESS_TABLE + (counter%16)*16 + 4]==CREATED || [PROCESS_TABLE + (counter%16)*16 + 4]==READY)) then
				newPID = counter % 16;
				break;
			endif;
			
			counter = counter + 1;	
		endwhile;
	endif;
endif;

PTBR = [PROCESS_TABLE + newPID * 16 + 14];
PTLR = [PROCESS_TABLE + newPID * 16 + 15];

[SYSTEM_STATUS_TABLE + 5*CORE + 1] = newPID;

if([PROCESS_TABLE + newPID * 16 + 4] == CREATED) then
	[PROCESS_TABLE + newPID * 16 + 4] = RUNNING;
	BP = [[PROCESS_TABLE + newPID*16 + 11]*512];
	[PROCESS_TABLE + newPID * 16 + 9] = 0; 
	
	R1 = RELEASE_LOCK;
	R2 = SCHED_LOCK;
	call ACCESS_CONTROL;
	
	SP = [PROCESS_TABLE + newPID*16 + 13];
	// // breakpoint;
	ireturn;
endif;

[PROCESS_TABLE + newPID * 16 + 4] = RUNNING;

// multipush (R3);
R1 = RELEASE_LOCK;
R2 = SCHED_LOCK;
call ACCESS_CONTROL;
// multipop (R3);

SP = [PROCESS_TABLE + newPID * 16 + 11] * 512 + [PROCESS_TABLE + newPID * 16 + 12];
multipop(BP);
// // breakpoint;
return;





























































// // // breakpoint;
// // Pushing BP of current process because expl program does not save the BP while the schduler is called from the timer
// multipush(BP);
// // 2 Obtain the PID of currently executing process from System Status Table.



// alias processTableEntryAddress R1;
// processTableEntryAddress = PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 5*CORE + 1] * 16;


// // Note that instead of saving the actual value of KPTR, we are saving KPTR%512. This is because the OS design stipulates that KPTR must contain the offset of the kernel stack pointer within the User Area Page. This is done so as to allow the OS to relocate the User Area Page if necessary.
// [processTableEntryAddress + 12] = SP % PAGE_SIZE;
// [processTableEntryAddress + 14] = PTBR;
// [processTableEntryAddress + 15] = PTLR;

// // call AQUIRE SCHEDULER LOCK
// multipush(R1);
// R1 = ACQUIRE_SCHED_LOCK;
// call ACCESS_CONTROL;
// multipop(R1);

// alias newPID R2;

// alias newProcessTableEntryAddress R3;
// alias otherCoreProcessId R4;


// newPID = -1;

// if(CORE == PRIMARY_CORE) then 


//     // if (PAGING_STATUS in the System Status Table is not 0) (Paging is ongoing )
//     if( [SYSTEM_STATUS_TABLE + 5] != 0 ) then

//     // If the paging process is not blocked  ( the paging process is executing a disk operation )
//         if([PROCESS_TABLE + 16*SWAPPER_DAEMON +4] != WAIT_DISK) then
//             // Choose the Swapper Daemon to be scheduled.
//             newPID = SWAPPER_DAEMON;
//         else   
//             // else  Choose Idle Process for scheduling.
//             newPID = IDLE_PROCESS;

//         endif;

//     endif;
//     // IDLE2 (PID=14) must not be scheduled. (IDLE2 is scheduled only in the secondary).
    
//     // The Process which is currently running on the secondary core must not be scheduled (This can be determined by reading CURRENT_PID2 field of the system status table ).

//     // If LOGOUT_STATUS=1 and the secondary core is not running IDLE2, then schedule IDLE (wait for the current running process to be scheduled out of the secondary core).
//     if([SYSTEM_STATUS_TABLE + 7] == 1 && [SYSTEM_STATUS_TABLE+6] != IDLE2_PROCESS) then
//         newPID = IDLE_PROCESS;
//     endif;

//     otherCoreProcessId = [SYSTEM_STATUS_TABLE + 6];
// else // if(CORE == SECONDARY_CORE) then

//     // If PAGING_STATUS or LOGOUT_STATUS is set (in the system status table ), then IDLE2 must be scheduled.
//     if([SYSTEM_STATUS_TABLE + 5] != 0 || [SYSTEM_STATUS_TABLE + 7] == 1) then
//         newPID = IDLE2_PROCESS;
//     endif;
//     // IDLE (PID=0), LOGIN (PID=1), SHELL (PID=2) and SWAPPER_DAEMON (PID=15) should never be scheduled, as the eXpOS design stipulates that these processes will run only on the primary.
//     // Schedule only processes 2-14 (inclusive) on the secondary core.
//     // Process which is currently running on the primary core must not be scheduled (read CURRENT_PID field of the system status table ).
//     // The PID of the process that is selected for scheduling in the secondary core must be set to CURRENT_PID2 field of the system status table.

   
//     otherCoreProcessId = [SYSTEM_STATUS_TABLE + 1];

// endif;








//     //  Find the next non swapped process to schedule using the Round Robin scheduling technique, 

//     // Round Robin algorithm for scheduling

//     // Iterate through the Process Table entries, starting from the succeeding entry of the current process to find a process in READY or CREATED state.
//     // If no such process can be found, select the idle process as the new process to be scheduled. Save PID of new process to be scheduled as newPID.
// if(newPID == -1) then
//     alias iter R8;
//     alias currentPID R9;
//     currentPID = [SYSTEM_STATUS_TABLE + 5*CORE + 1] ;
//     iter =  currentPID+1 ; // current id +1

//     while(iter < MAX_PROC_NUM) do
//         processTableEntryAddress = PROCESS_TABLE + iter * 16;
//         // finding a non swapped process in ready or created state
//         if((iter != otherCoreProcessId) && ([processTableEntryAddress+6] == 0) && ([processTableEntryAddress + 4] == READY || [processTableEntryAddress + 4] == CREATED)  ) then
//             if(CORE == PRIMARY_CORE && iter != IDLE2_PROCESS && iter != IDLE_PROCESS && iter != SWAPPER_DAEMON) then
//                 newPID = iter;
//                 break;
//             else
//                 if(CORE == SECONDARY_CORE && iter != IDLE2_PROCESS && iter != IDLE_PROCESS && iter != LOGIN_PROCESS && iter != SHELL_PROCESS && iter != SWAPPER_DAEMON) then
//                     newPID = iter;
//                     break;
//                 endif;
//             endif;
//         endif;
//         iter=iter+1;
//     endwhile;


//     if(newPID == -1) then
//         iter = 0;
//         while(iter <  currentPID) do
//             processTableEntryAddress = PROCESS_TABLE + iter * 16;
//             // finding a non swapped process in ready or created state
//             if( (iter != otherCoreProcessId) &&([processTableEntryAddress+6] == 0) && ([processTableEntryAddress + 4] == READY || [processTableEntryAddress + 4] == CREATED)  ) then
//                 if(CORE == PRIMARY_CORE && iter != IDLE2_PROCESS && iter != IDLE_PROCESS && iter != SWAPPER_DAEMON) then
//                 newPID = iter;
//                 break;
//                 else
//                     if(CORE == SECONDARY_CORE && iter != IDLE2_PROCESS && iter != IDLE_PROCESS && iter != LOGIN_PROCESS && iter != SHELL_PROCESS && iter != SWAPPER_DAEMON) then
//                         newPID = iter;
//                         break;
//                     endif;
//                 endif;
//             endif;
//             iter=iter+1;
//         endwhile;
//     endif;

//     if(newPID == -1) then
//         if(CORE == PRIMARY_CORE) then
//             newPID = IDLE_PROCESS;
//         else
//             newPID = IDLE2_PROCESS;
//         endif;
//     endif;

// endif;







// //  Restore the SP, PTBR and PTLR values from the Process Table entry for the new process.
// newProcessTableEntryAddress = PROCESS_TABLE + newPID * 16;


// // Set the PID field of the System Status Table as newPID.
// [SYSTEM_STATUS_TABLE + 5*CORE + 1] = newPID;
// [newProcessTableEntryAddress + 9] = 0; // MODE FLAG
// PTBR = [newProcessTableEntryAddress + 14];
// PTLR = [newProcessTableEntryAddress + 15];

// if([newProcessTableEntryAddress + 4] == CREATED) then
    
//     [newProcessTableEntryAddress + 4] = RUNNING;

//     // Store the value in the first word of the kernel stack to the BP register.    
//     BP = [[newProcessTableEntryAddress + 11] * PAGE_SIZE];
//     // calling RELEASE SCHEDULER LOCK
//     multipush(R1,R2,R3);
//     R1 = RELEASE_LOCK;
//     R2 = SCHED_LOCK;
//     call ACCESS_CONTROL;
//     multipop(R1,R2,R3);
    
//     SP = [newProcessTableEntryAddress +13];
//     ireturn;
// endif;

// [newProcessTableEntryAddress + 4] = RUNNING;

// //Set back Kernel SP, PTBR , PTLR
// // calling RELEASE SCHEDULER LOCK
// multipush(R1,R2,R3);
// R1 = RELEASE_LOCK;
// R2 = SCHED_LOCK;
// call ACCESS_CONTROL;
// multipop(R1,R2,R3);
// SP =  [newProcessTableEntryAddress + 11] * PAGE_SIZE + [newProcessTableEntryAddress + 12] ;

// multipop(BP);
// return;

